/***********************************************
 *            Digital I/O                      *
 ***********************************************/
/* reads tristate port regiser */
uint8_t  usbDTristateR_USB1608FS_Plus(libusb_device_handle *udev)
{
  /*
    This command reads or writes the digital port tristate
    register.  The tristate register determines if the
    latch register value is driven onto the port pin.  A
    '1' in the tristate register makes the corresponding
    pin an input, a '0' makes it an output.
  */
  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  uint8_t data = 0x0;

  if (libusb_control_transfer(udev, requesttype, DTRISTATE, 0x0, 0x0, (unsigned char *) &data, sizeof(data), HS_DELAY) < 0) {
    printf("usbDTristateR_USB1608FS_Plus: error in libusb_control_transfer().\n");
  }
  return data;
}

void usbDTristateW_USB1608FS_Plus(libusb_device_handle *udev, uint8_t value)
{
  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (libusb_control_transfer(udev, requesttype, DTRISTATE, value, 0x0, NULL, 0x0, HS_DELAY) < 0) {
    printf("usbDTristateW_USB1208HS: error in libusb_control_transfer().\n");
  }
  return;
}

/* reads digital port  */
uint8_t usbDPort_USB1608FS_Plus(libusb_device_handle *udev)
{
  /*
    This command reads the current state of the digital port pins
    or writes to the latch
   */

  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  uint8_t data;

  if (libusb_control_transfer(udev, requesttype, DPORT, 0x0, 0x0, (unsigned char *) &data, sizeof(data), HS_DELAY) < 0) {
    printf("usbDPort_USB1608FS_Plus: error in libusb_control_transfer().\n");
  }
  return data;
}

/* read digital port */
uint8_t usbDLatchR_USB1608FS_Plus(libusb_device_handle *udev)
{
  /*
    This command reads or writes the digital port latch register.  The
    power on default is all 0.
  */
  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  uint16_t data = 0x0;
  
  if (libusb_control_transfer(udev, requesttype, DLATCH, 0x0, 0x0, (unsigned char *) &data, sizeof(data), HS_DELAY) < 0) {
    printf("usbDLatchR_USB1608FS_Plus: error in libusb_control_transfer().\n");
  }
  return data;
}

void usbDLatchW_USB1608FS_Plus(libusb_device_handle *udev, uint8_t value)
{
  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (libusb_control_transfer(udev, requesttype, DLATCH, value, 0x0, NULL, 0x0, HS_DELAY) < 0) {
    printf("usbDLatchW_USB1608FS_Plus: error in libusb_control_transfer().\n");
  }
  return;
}

/***********************************************
 *            Analog Input                     *
 ***********************************************/

void usbAInScanConfigR_USB1608FS_Plus(libusb_device_handle *udev, uint8_t *ranges)
{
  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  int ret = -1;
  ret = libusb_control_transfer(udev, requesttype, AIN_CONFIG, 0x0, 0x0, (unsigned char *) ranges, 0x8, HS_DELAY);
  if (ret < 0) {
    perror("usbAInScanConfigR_USB1608FS_Plus: error in reading ranges.");
  }
}

/***********************************************
 *            Counter/Timer                    *
 ***********************************************/
void usbCounterInit_USB1608FS_Plus(libusb_device_handle *udev)
{
  /*
    This command initializes the 32-bit event counter.  On a write, the
    specified counter (0 or 1) will be reset to zero.
  */

  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  libusb_control_transfer(udev, requesttype, COUNTER, 0x0, 0x0, NULL, 0x0, HS_DELAY);
  return;
}

uint32_t usbCounter_USB1608FS_Plus(libusb_device_handle *udev)
{
  /*
    This command reads the 32-bit event counter.  
  */

  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  uint32_t counts = 0x0;

  libusb_control_transfer(udev, requesttype, COUNTER, 0x0, 0x0, (unsigned char *) &counts, sizeof(counts), HS_DELAY);
  return counts;
}

/***********************************************
 *            Memory Commands                  *
 ***********************************************/
void usbWriteCalMemory_USB1608FS_Plus(libusb_device_handle *udev, uint16_t address, uint16_t count, uint8_t data[])
{

  uint16_t unlock_code = 0xaa55;
  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (count > 768) {
    printf("usbWriteCalMemory_USB1608FS_Plus: max bytes that can be written is 768.");
    return;
  }

  if (address > 0x2ff) {
    printf("usbWriteCalMemory_USB1608FS_Plus: address must be in the range 0 - 0x2ff.");
    return;
  }

  libusb_control_transfer(udev, requesttype, CAL_MEMORY, 0x300, 0x0, (unsigned char *) &unlock_code, sizeof(unlock_code), HS_DELAY); // unlock memory
  libusb_control_transfer(udev, requesttype, CAL_MEMORY, address, 0x0, (unsigned char *) data, count, HS_DELAY);
  libusb_control_transfer(udev, requesttype, CAL_MEMORY, 0x300, 0x0, (unsigned char *) 0x0, sizeof(uint16_t), HS_DELAY); // lock memory
}

void usbReadUserMemory_USB1608FS_Plus(libusb_device_handle *udev, uint16_t address, uint16_t count, uint8_t data[])
{
    
  /*
    These commands allow for reading and writing the nonvolatile user
     memory. wLength specifies the number of bytes to read or write.
     The user memory is 256 bytes (address 0-0xff)
  */

  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (count > 256) {
    printf("usbReadUserMemory_USB1608FS_Plus: max bytes that can be written is 256.");
    return;
  }

  if (address > 0xff) {
    printf("usbReadUserMemory_USB1608FS_Plus: address must be in the range 0 - 0xff.");
    return;
  }
  libusb_control_transfer(udev, requesttype, USER_MEMORY, address, 0x0, (unsigned char *) data, count, HS_DELAY);
}

void usbWriteUserMemory_USB1608FS_Plus(libusb_device_handle *udev, uint16_t address, uint16_t count, uint8_t data[])
{

  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (count > 255) {
    printf("usbWriteUserMemory_USB1608FS_Plus: max bytes that can be written is 768.");
    return;
  }

  if (address > 0xff) {
    printf("usbWriteUserMemory_USB1608FS_Plus: address must be in the range 0 - 0x2ff.");
    return;
  }
  libusb_control_transfer(udev, requesttype, USER_MEMORY, address, 0x0, (unsigned char *) data, count, HS_DELAY);
}

void usbReadMBDMemory_USB1608FS_Plus(libusb_device_handle *udev, uint16_t address, uint16_t count, uint8_t data[])
{
  /*
    These commands allow for reading and writing the nonvolatile MBD memory. count must
    be less than or equal to 1024 (address 0-0x3ff).
  */
  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (count > 1024) {
    printf("usbReadMBDMemory_USB1608FS_Plus: max bytes that can be written is 1024.");
    return;
  }

  if (address > 0x3ff) {
    printf("usbReadMBDMemory_USB1608FS_Plus: address must be in the range 0 - 0x3ff.");
    return;
  }
  libusb_control_transfer(udev, requesttype, MBD_MEMORY, address, 0x0, (unsigned char *) data, count, HS_DELAY);
}

void usbWriteMBDMemory_USB1608FS_Plus(libusb_device_handle *udev, uint16_t address, uint16_t count, uint8_t data[])
{

  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);

  if (count > 1024) {
    printf("usbWriteMBDMemory_USB1608FS_Plus: max bytes that can be written is 1024.");
    return;
  }

  if (address > 0x3ff) {
    printf("usbWriteUserMemory_USB1608FS_Plus: address must be in the range 0 - 0x3ff");
    return;
  }
  libusb_control_transfer(udev, requesttype, USER_MEMORY, address, 0x0, (unsigned char *) data, count, HS_DELAY);
}

/***********************************************
 *          Miscellaneous Commands             *
 ***********************************************/

void usbMBDCommand_USB1608FS_Plus(libusb_device_handle *udev, uint8_t str[])
{
  /*
    This command is the interface for text-based MBD commands and
    responses.  The length of the string must be passed in wLength for an
    OUT transfer.
  */

  uint8_t requesttype = (HOST_TO_DEVICE | VENDOR_TYPE | DEVICE_RECIPIENT);
  libusb_control_transfer(udev, requesttype, MBD_COMMAND, 0x0, 0x0, (unsigned char *) str, strlen((char *) str), HS_DELAY);

}

void usbMBDRaw_USB1608FS_Plus(libusb_device_handle *udev, uint8_t cmd[], uint16_t size)
{
  /*
    This command is the interface for binary responses to certain MBD commands.
   */

  uint8_t requesttype = (DEVICE_TO_HOST | VENDOR_TYPE | DEVICE_RECIPIENT);
  libusb_control_transfer(udev, requesttype, MBD_RAW, 0x0, 0x0, (unsigned char *) cmd, size, HS_DELAY);
}

void cleanup_USB1608FS_Plus(libusb_device_handle *udev)
{
  if (udev) {
    libusb_clear_halt(udev, LIBUSB_ENDPOINT_IN|1);
    libusb_release_interface(udev, 0);
    libusb_close(udev);
  }
}

double volts_USB1608FS_Plus(uint16_t value, uint8_t range)
{
  double volt = 0.0;
  switch(range) {
    case BP_10V:   volt = (value - 0x8000)*10.0/32768.; break;
    case BP_5V:    volt = (value - 0x8000)*5.0/32768.; break;
    case BP_2_5V:  volt = (value - 0x8000)*2.5/32768.; break;
    case BP_2V:    volt = (value - 0x8000)*2.0/32768.; break;
    case BP_1_25V: volt = (value - 0x8000)*1.25/32768.; break;
    case BP_1V:    volt = (value - 0x8000)*1.0/32768.; break;
    case BP_625V:  volt = (value - 0x8000)*0.625/32768.; break;
    case BP_3125V: volt = (value - 0x8000)*0.3125/32768.; break;
    default: printf("Unknown range.\n"); break;
  }
  return volt;
}
